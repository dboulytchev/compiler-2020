-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  s (l) |> lift (p |> bypass (s (r)))
}

local rCompOperation = createRegexp("<=\\|>=\\|==\\|!=\\|[<>]", "compOperation");
local rAddOperation = createRegexp("\-\\|[+]", "addOperation");
local rMulOperation = createRegexp("[*/%]", "mulOperation");
local rOperation = createRegexp("<=\\|>=\\|==\\|!=\\|!!\\|&&\\|\-\\|[+*/%<>]", "binop"); 

                            
fun binExp(arg1, op_arg, arg2) {
    (arg1 |> fun (l) {
        s(op_arg) |> fun (op) {
            arg2 @ fun (r) {Binop(op, l, r)}
            }
         }
    ) | arg2
}

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr ("(", orExp, ")")),
                            
orExp = memo $ eta (binExp(orExp, "!!", andExp)),

andExp = memo $ eta (binExp(andExp, "&&", logicExp)),
                            
logicExp = memo $ eta (binExp(logicExp, rCompOperation, addExp)),
                                
addExp = memo $ eta (binExp(addExp, rAddOperation, mulExp)),
                                
mulExp = memo $ eta (binExp(mulExp, rMulOperation, primary));
                                
                                
local st = memo $ eta (kSkip @ fun (_) {Skip} | 
                       kRead |> lift (primary @ fun(Var (x)) {Read (x)}) |
                       kWrite |> lift (orExp @ fun (x) {Write (x)}) |
                       lident |> fun (x) {s(":=") |> lift (orExp @ fun (e) {Assn (x, e)})}
                      );

local stmt = memo $ eta (st |
                         st |> fun (s1) { s(";") |> lift (stmt @ fun (s2) {Seq (s1, s2)}) } 
                        );

-- Public top-level parser
public parse = stmt;
        
