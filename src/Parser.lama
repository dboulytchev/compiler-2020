import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun binary(op) {
  [s(op), fun(left, right) { Binop (op, left, right) }]

}

local ops = { [Left, singleton (binary("!!"))],
              [Left, singleton (binary("&&"))],
              [Nona, { binary("<"),
                       binary("<="),
                       binary(">"),
                       binary(">="),
                       binary("=="),
                       binary("!=")
                     }
              ],
              [Left, { binary("+"),
                       binary("-")
                     }
              ],
              [Left, { binary("*"),
                       binary("/"),
                       binary("%")
                     }
              ]
           };


-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (s ("("), expression, s (")")));

local expression = memo $ eta (expr (ops, primary)(id));

local stElif = memo $ eta (kElif |> lift (expression |> fun (expr) {
                               kThen |> lift (stmt |> fun (stmt1) {
                                   kElse |> lift (stmt |> fun (stmt2) {
                                       kFi @ lift (If (expr, stmt1, stmt2))
                                   }) |
                               kFi @ lift (If (expr, stmt1, Skip)) |
                               stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                               })
                           })
                        );

 local st = memo $ eta (kSkip @ lift(Skip) |
                        kRead |> lift (primary @ fun (Var (name)) { Read (name) }) |
                        kWrite |> lift (expression @ fun (value) { Write (value) }) |
                        lident |> fun (name) { s(":=") |> lift (expression @ fun (value) { Assn (name, value) }) } |
                        kWhile |> lift (expression |> fun (cond) {
                            kDo |> lift (stmt |> fun (body) {
                                kOd @ lift (While (cond, body))
                                })
                            }) |
                        kRepeat |> lift (stmt |> fun (body) {
                            kUntil |> lift (expression @ fun (cond) {Repeat (body, cond)})
                        }) |
                        kIf |> lift (expression |> fun (cond) {
                            kThen |> lift (stmt |> fun (onTrue) {
                                kElse |> lift (stmt |> fun (onFalse) {
                                   kFi @ lift (If (cond, onTrue, onFalse))
                                }) |
                            kFi @ lift (If (cond, onTrue, Skip)) |
                            stElif @ fun (onNext) {If (cond, onTrue, onNext)}
                            })
                        }) |
                        kFor |> lift (stmt |> fun (init) {
                            s(",") |> lift (expression |> fun (cond) {
                                s(",") |> lift (stmt |> fun (update) {
                                    kDo |> lift (stmt |> fun (body) {
                                        kOd @ lift (Seq (init, While (cond, Seq(body, update))))
                                    })
                                })
                            })
                        })
                      );


local stmt = memo $ eta (st |
                         st |> fun (first) { s(";") |> lift (stmt @ fun (second) { Seq (first, second) }) }
                        );


-- Public top-level parser
public parse = stmt;
