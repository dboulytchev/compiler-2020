-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

fun opPair(op) {
  [s(op), fun(l, r) {Binop(op, l, r)}]
}

local operations = {
  [
    Left,
    singleton( opPair("!!") )
  ],
  [
    Left,
    singleton( opPair("&&") )
  ],
  [
    Left,
    {
      opPair("<"),
      opPair("<="),
      opPair(">"),
      opPair(">="),
      opPair("=="),
      opPair("!=")
    }
  ],
  [
    Left,
    {
      opPair("+"),
      opPair("-")
    }
  ],
  [
    Left,
    {
      opPair("*"),
      opPair("/"),
      opPair("%")
    }
  ]
};

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  s (l) |> lift (p |> bypass (s (r)))
}


-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident @ fun(x) {Var (x)} |
                            inbr ("(", exp, ")"));


local exp = memo $ eta ( expr(operations, primary)(id) );

local stmt = memo $ eta ( 
  (s("read")  |> lift(inbr("(", lident, ")"))) @ fun(z) {Read(z)} |
  (s("write") |> lift(primary)) @ fun(x) {Write(x)}         |  
  (lident  |> fun(var) {(s(":=") |> lift(exp)) @ fun(val) {Assn(var, val)}})
);


local inParse = memo $ eta (
    empty @ lift(None)
  | ( s(";") |> lift(stmt) ) |> fun(z) { inParse @ fun(rest) {
     case rest of 
       None -> Some(z)
     | Some(v) -> Some(Seq(z, v))
     esac
  }}
);

-- Public top-level parser
public parse = memo $ eta (
  stmt |> fun(first) { inParse @ fun(rest) {case rest of 
      None -> first
    | Some(v) -> Seq(first, v)
    esac
  }}
);
