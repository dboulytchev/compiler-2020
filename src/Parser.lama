-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun descr (op) {
  [s (op), fun (l, r) { Binop (op, l, r) }]
}

local ops = {
  [Left, descr ("!!") : {}],
  [Left, descr ("&&") : {}],
  [Left, { descr ("=="), descr ("!=") }],
  [Left, { descr ("<"), descr ("<="), descr (">"), descr (">=") }],
  [Left, { descr ("+"), descr ("-") }],
  [Left, { descr ("*"), descr ("/"), descr ("%") }]
};

-- Primary expression
local primary = memo $ eta (
  decimal @ fun (x) { Const (stringInt (x)) } 
| lident  @ fun (x) { Var (x) } 
| inbr (lbr, exp, rbr)
);

local exp = memo $ eta (expr (ops, primary) (id));

local ifPart = 
exp |> fun (e) {
  kThen |> lift (
    stmt |> fun (st) {
      elsePart @ fun (sf) { If (e, st, sf) }
    | kFi      @ lift (If (e, st, Skip))
    }
  ) 
};

local elsePart = memo $ eta (
  kElif |> lift (ifPart)
| kElse |> lift (
    stmt |> fun (s) {
      kFi @ lift (s)
    }
  )
);

local eIf = kIf |> lift (ifPart);

local whileHeader = memo $ eta (
  kDo |> lift (stmt |> fun (s) { kOd @ lift (s) } )
);

local eWhile = memo $ eta (
  kWhile |> lift (exp |> fun (e) { whileHeader @ fun (s) { While (e, s) } })
);

local eRepeat = memo $ eta (
  kRepeat |> lift (
    stmt |> fun (s) {
      kUntil |> lift (
        exp @ fun (e) { Repeat (s, e) }
      )
    }
  )
);

local eFor = memo $ eta (
  kFor |> lift (
    stmt |> fun (init) {
      comma |> lift (
        exp |> fun (cond) {
          comma |> lift (
            stmt |> fun (step) {
              whileHeader @ fun (body) { Seq (init, While (cond, Seq (body, step))) }
            } 
          )
        }
      )
    }
  )
);

local part = memo $ eta (
  kRead  |> lift (inbr (lbr, lident, rbr) @ fun (x) { Read (x) })
| kWrite |> lift (inbr (lbr, exp, rbr) @ fun (x) { Write (x) })
| lident |> fun (i) { (s (":=") |> lift (exp)) @ fun (e) { Assn (i, e) } }
| kSkip @ lift (Skip)
| eIf
| eWhile
| eRepeat
| eFor
);

local stmt = memo $ eta (
  list0By (part, s (";")) @ fun (l) { foldr (fun (acc, p) { Seq (p, acc) }, Skip, l) }
);

-- Public top-level parser
public parse = stmt;