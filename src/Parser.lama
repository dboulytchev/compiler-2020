-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun binop (o) {
  [s(o), fun(l, r) { Binop (o, l, r) }]
}

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr ("(", exp, ")"));

local exp = memo $ eta (expr(
{ 
  [Left, singleton(binop("!!"))],
  [Left, singleton(binop("&&"))],
  [Nona, {binop("<"), binop(">"), binop("<="), binop(">="), binop("=="), binop("!=")}],
  [Left, {binop("+"), binop("-")}],
  [Left, {binop("*"), binop("/"), binop("%")}]
}, primary)(id));

local st = memo $ eta (kSkip @ lift(Skip) |
                       kRead |> lift(primary @ fun (Var(x)) {Read(x)}) |
                       kWrite |> lift(exp @ fun (x) {Write(x)}) |
                       lident |> fun(x) {s(":=") |> lift(exp @ fun (e) {Assn(x, e)})});


local stmt = memo $ eta (st |
                         st |> fun (s1) {s(";") |> lift(stmt @ fun (s2) {Seq(s1, s2)})});
   

-- Public top-level parser
public parse = stmt;
