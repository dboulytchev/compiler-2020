-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  s (l) |> lift (p |> bypass (s (r)))
}

fun bin (oper) {
  [s (oper), fun (l, r) {Binop (oper, l, r)}]
}

local oper = {
    [Left, singleton (bin ("!!"))],
    [Left, singleton (bin ("&&"))],
    [Nona, {bin ("<"), bin (">"),
            bin ("<="), bin (">="),
            bin ("=="), bin ("!=")}],
    [Left, {bin ("+"), bin ("-")}],
    [Left, {bin ("*"), bin ("/"), bin ("%")}]
};

-- Primary expression
local primary = memo $ eta (decimal @ fun (c) {Const (stringInt (c))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr ("(", expression, ")"));

local expression = memo $ eta (expr (oper, primary)(id));

local statement = memo $ eta (
    kSkip  @  lift (Skip)
  | kWrite |> lift (expression @ fun (e) {Write (e)})
  | kRead  |> lift (primary @ fun (Var (p)) {Read (p)})
  | lident |> fun (x) { s (":=") |> lift (expression @ fun (e) {Assn (x, e)}) }
);
   

-- Public top-level parser
public parse = memo $ eta (
    statement
  | statement |> fun (s1) { s (";") |> lift (parse @ fun (s2) {Seq (s1, s2)}) }
);

--    kIf |> lift (expression |> fun (condition) {
--      kThen |> lift (parse |> fun (then_statment) {
--        elif_statment @ fun (else_statment) { If (condition, then_statment, else_statment)}
--      })
--    })|


 
