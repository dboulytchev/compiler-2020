-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (p) {
  s ("(") |> lift (p |> bypass (s (")")))
}

local ops = map(fun([type, ops]) {
    [type, map(fun(op) {
      [s(op), fun (l, r) { Binop(op, l, r) }]
    }, ops)]
  }, {
    [Left, singleton("!!")],
    [Left, singleton("&&")],
    [Nona, { "==", "!=", "<", "<=", ">", ">=" }],
    [Left, { "+", "-" }],
    [Left, { "*", "/", "%" }]
  }
);

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (exp));

local exp = memo $ eta (expr(ops, primary)(id));

local elifStmt = memo $ eta(
    kElif |> lift(exp |> fun(cond) {
      kThen |> lift(stmt |> fun(thenStmt) {
        elifStmt @ fun(elseStmt) { If(cond, thenStmt, elseStmt) }
      })
    })
  | kElse |> lift(stmt |> fun(elseStmt) {
      kFi @ lift(elseStmt)
    })
  | kFi @ lift(Skip)
);

local substmt = memo $ eta (
    lident |> fun(x) {
      (s(":=") |> lift(exp)) @ fun(val) { Assn(x, val) }
    }
  | kSkip @ lift(Skip)
  | (kRead |> lift(inbr(lident))) @ fun(x) { Read(x) }
  | (kWrite |> lift(exp)) @ fun(val) { Write(val) }
  | kWhile |> lift(exp |> fun(cond) {
      kDo |> lift(stmt |> fun(loopStmt) {
        kOd @ lift(While(cond, loopStmt))
      })
    })
  | kRepeat |> lift(stmt |> fun(loopStmt) {
      kUntil |> lift(exp @ fun(cond) { Repeat(loopStmt, cond) })
    })
  | kFor |> lift(stmt |> fun(init) {
      s(",") |> lift(exp |> fun(cond) {
        s(",") |> lift(stmt |> fun(step) {
          kDo |> lift(stmt |> fun(loopStmt) {
            kOd @ lift(Seq(init, While(cond, Seq(loopStmt, step))))
          })
        })
      })
    })
  | kIf |> lift(exp |> fun(cond) {
      kThen |> lift(stmt |> fun(thenStmt) {
        elifStmt @ fun(elseStmt) { If(cond, thenStmt, elseStmt) }
      })
    })
);

local stmt = memo $ eta (
  substmt | substmt |> fun (stmt1) {
    (s(";") |> lift(stmt)) @ fun (stmt2) { Seq(stmt1, stmt2) }
  }
);
   
-- Public top-level parser
public parse = stmt;
