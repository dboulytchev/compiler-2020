-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun bin (o) { 
  [s(o), fun(l, r) { Binop (o, l, r) }]
}

local ops = { [Left, singleton (bin ("!!"))],
              [Left, singleton (bin ("&&"))],
              [Nona, { bin ("<"),
                       bin (">"),
                       bin ("<="),
                       bin (">="),
                       bin ("=="),
                       bin ("!=") }],
              [Left, { bin ("+"),
                       bin ("-")}],
              [Left, { bin ("*"),
                       bin ("/"),
                       bin ("%")}]};

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (s ("("), exp, s (")"))),
      exp = memo $ eta (expr (ops, primary)(id));

local stElif = memo $ eta ( kElif |> lift (exp |> fun (expr) {
                              kThen |> lift (stmt |> fun (stmt1) {
                                kElse |> lift (stmt |> fun (stmt2) {
                                  kFi @ lift (If (expr, stmt1, stmt2))
                                })
                                | kFi @ lift (If (expr, stmt1, Skip))
                                | stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                              })
                            })
                          );


local st = memo $ eta (kSkip @ lift (Skip)
                         | kRead |> lift (primary @ fun (Var (x)) { Read (x) })
                         | kWrite |> lift (exp @ fun (x) { Write (x) })
                         | lident |> fun (x) { s(":=") |> lift (exp @ fun (expr) {Assn (x, expr) }) }
                         | kIf |> lift (exp |> fun(expr) {
                             kThen |> lift (stmt |> fun (stmt1) {
                               kElse |> lift ( stmt |> fun (stmt2) {
                                 kFi @ lift (If (expr, stmt1, stmt2))
                               })
                               | kFi @ lift (If (expr, stmt1, Skip))
                               | stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                             })
                           })
                         | kWhile |> lift (exp |> fun (expr) {
                             kDo |> lift (stmt |> fun (state) {
                               kOd @ lift (While (expr, state))
                             })
                           })
                         | kRepeat |> lift (stmt |> fun (state) {
                             kUntil |> lift (exp @ fun (expr) {Repeat (state, expr)})
                           })
                         | kFor |> lift (stmt |> fun (stmt1) {
                             s(",") |> lift (exp |> fun (expr) {
                               s(",") |> lift (stmt |> fun (stmt2) {
                                 kDo |> lift (stmt |> fun (stmt3) {
                                   kOd @ lift (Seq (stmt1, While (expr, Seq (stmt3, stmt2))))
                                 })
                               })
                             })
                           })
                         ); 


   
local stmt = memo $ eta (st 
                         | st |> fun (stmt1) { 
                             s(";") |> lift (stmt @ fun (stmt2) { Seq (stmt1, stmt2) })
                           }
                        );
-- Public top-level parser
public parse = stmt;
