-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

local ops = {
  [Left, singleton("!!")],
  [Left, singleton("&&")],
  [Nona, {"==", "!=", "<=", "<", ">=", ">"}],
  [Left, {"+", "-"}],
  [Left, {"*", "/", "%"}]
};

fun ops_gen(ops) {
  fun descriptor(op) {
    [s(op), fun (l, r) {Binop(op, l, r)}]
  }

  map(
    fun ([asoc, ops]) {
      [asoc, map(descriptor, ops)]
    },
    ops
  )
}

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr ("(", exp, ")")),
      exp = memo $ eta (expr(ops_gen(ops), primary)(id));

local stmt = memo $ eta (
  kRead  |> lift(inbr("(", lident, ")") @ fun (x) {Read(x)})
| kWrite |> lift(inbr("(", exp, ")") @ fun (x) {Write(x)})
| lident |> fun (left) {
    (s(":=") |> lift(exp)) @ fun (e) {Assn(left, e)}
  }
| kSkip @ lift(Skip)
);

local stmts = memo $ eta(
  stmt | (stmt |> fun (st) {
      (s(";") |> lift(stmts)) @ fun (seq) {Seq(st, seq)}
    })
);

-- Public top-level parser
public parse = stmts;

