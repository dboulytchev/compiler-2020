-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  s (l) |> lift (p |> bypass (s (r)))
}

fun binary (operation) {
  [s (operation), fun (left, right) {Binop (operation, left, right)}]
}

local operations = {
    [Left, singleton (binary ("!!"))],
    [Left, singleton (binary ("&&"))],
    [Nona, {binary ("<"), binary (">"),
            binary ("<="), binary (">="),
            binary ("=="), binary ("!=")}],
    [Left, {binary ("+"), binary ("-")}],
    [Left, {binary ("*"), binary ("/"), binary ("%")}]
};

-- Primary expression
local primary = memo $ eta (decimal @ fun (c) {Const (stringInt (c))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr ("(", expression, ")"));

local expression = memo $ eta (expr (operations, primary)(id));

local statement = memo $ eta (
    kSkip  @  lift (Skip)
  | kWrite |> lift (expression @ fun (e) {Write (e)})
  | kRead  |> lift (primary @ fun (Var (p)) {Read (p)})
  | lident |> fun (x) { s (":=") |> lift (expression @ fun (e) {Assn (x, e)}) }
);
   

-- Public top-level parser
public parse = memo $ eta (
    statement
  | statement |> fun (s1) { s (";") |> lift (parse @ fun (s2) {Seq (s1, s2)}) }
);
             
