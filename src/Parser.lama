-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun rParser (p, ops) {
  p |> fun (l) { (ops |> fun (bin) { rParser (p, ops) @ fun (r) { bin (l, r) } }) | (empty @ lift (l)) }
}

fun nParser (p, ops) {
  p |> fun (l) { (ops |> fun (bin) { p @ fun (r) { bin (l, r) } }) | (empty @ lift (l)) }
}

fun lParser (p, ops) {
  fun internal (l) { 
    (ops |> fun (bin) { p |> fun (r) { internal (bin (l, r)) } }) | (empty @ lift (l)) 
  }
  p |> internal
}

fun binOpParser (op) {
  s (op) @ lift (fun (l, r) { Binop (op, l, r) })
}

fun binOpsParser (op : ops) {
  foldl (infix |, binOpParser (op), map (binOpParser, ops))
}

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) { Const (stringInt (x))} |
                            lident  @ fun (x) { Var (x)} |
                            inbr (s ("("), exp, s (")"))),
      exp = memo $ eta (fun (p, [assoc, ops]) { assoc (p, binOpsParser (ops)) }.foldr (primary,
                        [lParser, "!!" : {}] : 
                        [lParser, "&&" : {}] : 
                        [nParser, {"==", "!=", "<=", ">=", "<", ">"}] : 
                        [lParser, {"+", "-"}] :
                        [lParser, {"*", "/", "%"}] : {}));

local stmt = memo $ eta ((kRead  |> lift (inbr (s ("("), lident, s (")")) @ fun (x) { Read  (x) }))
                       | (kWrite |> lift (inbr (s ("("), exp,    s (")")) @ fun (x) { Write (x) }))
                       | ifSt
                       | whileSt
                       | repeatSt
                       | forSt
                       | (kSkip  @  lift (Skip))
                       | (lident |> fun (a) { s (":=") |> lift (exp @ fun (b) { Assn (a, b) }) })),
      ifSt = memo $ eta (kIf |> lift (exp |> fun (eInit) { kThen |> lift (rParser (stmts @ fun (l) { fun (e, r) { If (e, l, r) } }, 
                                                                                   kElif |> lift ((exp @ fun (e1) { fun (l1, r1) { fun (e, r) { l1 (e, r1 (e1, r)) } } }) |> bypass (kThen)))
                                                                         |> fun (incomplete) { ((kElse |> lift (stmts |> bypass (kFi))) | (kFi @ lift (Skip))) 
                                                                                               @ fun (last) { incomplete (eInit, last) } }) })),
      whileSt = memo $ eta (kWhile |> lift (exp |> fun (e) { kDo |> lift ((stmts @ fun (s) { While (e, s) }) |> bypass (kOd)) })),
      repeatSt = memo $ eta (kRepeat |> lift (stmts |> fun (s) { kUntil |> lift (exp @ fun (e) { Repeat (s, e) }) })),
      forSt = memo $ eta (kFor |> lift (stmt |> fun (init) { s (",") |> lift (exp |> fun (cond) { s (",") |> lift (stmt |> fun (step) { kDo |> lift ((stmts @ fun (s) { Seq (init, While (cond, Seq (s, step))) }) |> bypass (kOd)) }) }) })),
      stmts = memo $ eta (rParser (stmt, s (";") @ lift (fun (a, b) { Seq (a, b) })));

-- Public top-level parser
public parse = stmts |> bypass (end);
