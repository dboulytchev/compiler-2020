-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

local rCompOperation = createRegexp("<=\\|>=\\|==\\|!=\\|[<>]", "compOperation");
local rAddOperation = createRegexp("\-\\|[+]", "addOperation");
local rMulOperation = createRegexp("[*/%]", "mulOperation");
local rOperation = createRegexp("<=\\|>=\\|==\\|!=\\|!!\\|&&\\|\-\\|[+*/%<>]", "binop"); 

                            
fun binExp(arg1, op_arg, arg2) {
    (arg1 |> fun (l) {
        s(op_arg) |> fun (op) {
            arg2 @ fun (r) {Binop(op, l, r)}
            }
         }
    ) | arg2
}

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (s ("("), orExp, s (")"))),

orExp = memo $ eta (binExp(orExp, "!!", andExp)),

andExp = memo $ eta (binExp(andExp, "&&", logicExp)),
                            
logicExp = memo $ eta (binExp(logicExp, rCompOperation, addExp)),
                                
addExp = memo $ eta (binExp(addExp, rAddOperation, mulExp)),
                                
mulExp = memo $ eta (binExp(mulExp, rMulOperation, primary));


local stElif = memo $ eta (kElif |> lift (orExp |> fun (e) {
                            kThen |> lift (stmt |> fun (s1) {
                                kElse |> lift (stmt |> fun (s2) {
                                        kFi @ lift (If (e, s1, s2))
                                    }) | 
                                kFi @ lift (If (e, s1, Skip)) | 
                                stElif @ fun (s2) {If (e, s1, s2)}
                                })
                            })
                        );                                
                                
local st = memo $ eta (kSkip @ fun (_) {Skip} | 
                       kRead |> lift (primary @ fun(Var (x)) {Read (x)}) |
                       kWrite |> lift (orExp @ fun (x) {Write (x)}) |
                       lident |> fun (x) {s(":=") |> lift (orExp @ fun (e) {Assn (x, e)})} |
                       kIf |> lift (orExp |> fun (e) {
                            kThen |> lift (stmt |> fun (s1) {
                                kElse |> lift (stmt |> fun (s2) {
                                        kFi @ lift (If (e, s1, s2))
                                    }) | 
                                kFi @ lift (If (e, s1, Skip)) | 
                                stElif @ fun (s2) {If (e, s1, s2)}
                                })
                            }) |
                       kWhile |> lift (orExp |> fun (e) {
                            kDo |> lift (stmt |> fun (s) {
                                kOd @ lift (While (e, s))
                                })
                            }) |
                       kRepeat |> lift (stmt |> fun (s) {
                            kUntil |> lift (orExp @ fun (e) {Repeat (s, e)})
                            }) |
                       kFor |> lift (stmt |> fun (s1) {
                            s(",") |> lift (orExp |> fun (e) {
                                s(",") |> lift (stmt |> fun (s2) {
                                    kDo |> lift (stmt |> fun (s3) {
                                        kOd @ lift (Seq (s1, While (e, Seq(s3, s2))))
                                        })
                                    })
                                })
                            }) 
                      );

local stmt = memo $ eta (st |
                         st |> fun (s1) { s(";") |> lift (stmt @ fun (s2) {Seq (s1, s2)}) } 
                        );   

-- Public top-level parser
public parse = stmt;
