-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  s (l) |> lift (p |> bypass (s (r)))
}

-- Rule generator for the second rule of Ostap's expr()
fun binopRule (op) { 
  [s (op), fun (l, r) {Binop (op, l, r)}]
}

-- List of available binary operations with rules
-- for Ostap's expr()    
local binopList = 
    {
    [Left, singleton (binopRule ("!!"))],
    [Left, singleton (binopRule ("&&"))],
    [Nona, { binopRule ("=="), binopRule ("<="), binopRule ("<"), binopRule (">="), binopRule (">"),
             binopRule ("!=") }],
    [Left, { binopRule ("+"), binopRule ("-") }],
    [Left, { binopRule ("*"), binopRule ("/"), binopRule ("%") }]
    };

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) { Const (stringInt (x)) } |
                            lident  @ fun (x) { Var (x) }               |
                            inbr ("(", exp, ")")),
      exp     = memo $ eta (expr(binopList, primary)(id));

local stmtSingle = memo $ eta (
                         kRead  |> lift(inbr("(", lident, ")") @ fun (x) { Read (x) } )           |  
                         kWrite |> lift(exp @ fun (x) { Write (x) } )                             |
                         lident |> fun (x) { s(":=") |> lift(exp @ fun (val) { Assn (x, val) }) } |
                         kSkip  @ lift (Skip)),                                                       
      stmt       = memo $ eta (stmtSingle |
                               stmtSingle |> fun (s1) { 
                                    (s(";") |> lift (stmt)) @ fun (s2) { Seq (s1, s2) } } );
                         
-- Public top-level parser
public parse = stmt;
             
