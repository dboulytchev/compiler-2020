-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;


-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

local rCompOperation = createRegexp ("<=\\|>=\\|==\\|!=\\|[<>]", "compOperation");
local rAddOperation = createRegexp ("\-\\|[+]", "addOperation");
local rMulOperation = createRegexp ("[*/%]", "mulOperation");
local rOperation = createRegexp ("<=\\|>=\\|==\\|!=\\|!!\\|&&\\|\-\\|[+*/%<>]", "binop");

fun binExp (arg1, arg_op, arg2) {
  (arg1 |> fun(left) {
      s(arg_op) |> fun (op) {
        arg2 @ fun (right) { Binop (op, left, right) }
      }
    }
  ) | arg2
}




-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (s("("), orExp, s(")"))),

      orExp = memo $ eta (binExp (orExp, "!!", andExp)),

      andExp = memo $ eta (binExp (andExp, "&&", logicExp)),

      logicExp = memo $ eta (binExp (logicExp, rCompOperation, addExp)),

      addExp = memo $ eta (binExp (addExp, rAddOperation, mulExp)),

      mulExp = memo $ eta (binExp (mulExp, rMulOperation, primary));

local stElif = memo $ eta ( kElif |> lift (orExp |> fun (expr) {
                              kThen |> lift (stmt |> fun (stmt1) {
                                kElse |> lift (stmt |> fun (stmt2) {
                                  kFi @ lift (If (expr, stmt1, stmt2))
                                })
                                | kFi @ lift (If (expr, stmt1, Skip))
                                | stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                              })
                            })
                          );


local substmt = memo $ eta (kSkip @ lift (Skip)
                         | kRead |> lift (primary @ fun (Var (x)) { Read (x) })
                         | kWrite |> lift (orExp @ fun (x) { Write (x) })
                         | lident |> fun (x) { s(":=") |> lift (orExp @ fun (expr) {Assn (x, expr) }) }
                         | kIf |> lift (orExp |> fun(expr) {
                             kThen |> lift (stmt |> fun (stmt1) {
                               kElse |> lift ( stmt |> fun (stmt2) {
                                 kFi @ lift (If (expr, stmt1, stmt2))
                               })
                               | kFi @ lift (If (expr, stmt1, Skip))
                               | stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                             })
                           })
                         | kWhile |> lift (orExp |> fun (expr) {
                             kDo |> lift (stmt |> fun (state) {
                               kOd @ lift (While (expr, state))
                             })
                           })
                         | kRepeat |> lift (stmt |> fun (state) {
                             kUntil |> lift (orExp @ fun (expr) {Repeat (state, expr)})
                           })
                         | kFor |> lift (stmt |> fun (stmt1) {
                             s(",") |> lift (orExp |> fun (expr) {
                               s(",") |> lift (stmt |> fun (stmt2) {
                                 kDo |> lift (stmt |> fun (stmt3) {
                                   kOd @ lift (Seq (stmt1, While (expr, Seq (stmt3, stmt2))))
                                 })
                               })
                             })
                           })
                         ); 



local stmt = memo $ eta (substmt 
                         | substmt |> fun (stmt1) { 
                             s(";") |> lift (stmt @ fun (stmt2) { Seq (stmt1, stmt2) })
                           }
                        );
   

-- Public top-level parser
public parse = stmt;
             
