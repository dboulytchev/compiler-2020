-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun binOp (op) {
  [s (op), fun (l, r) { Binop (op, l, r) }]
}

local ops = { [Left, singleton (binOp ("!!"))],
              [Left, singleton (binOp ("&&"))],
              [Nona, { binOp ("<"), binOp (">"), binOp ("<="), binOp ("=="), binOp (">="), binOp ("!=") }],
              [Left, { binOp ("+"), binOp ("-") }],
              [Left, { binOp ("*"), binOp ("/"), binOp ("%") }] 
};

-- Primary expression
local primary = memo $ eta (decimal @ fun (x) { Const (stringInt (x)) } |
                            lident  @ fun (x) { Var (x) } |
                            inbr (s("("), exp, s(")"))),
      exp = memo $ eta (expr (ops, primary)(id)),
      subIf = memo $ eta (kElif |> lift (exp |> fun (e) {
                            kThen |> lift (stmt |> fun (s1) {
                              kElse |> lift (stmt |> fun (s2) {
                                kFi @ lift (If (e, s1, s2))
                              }) |
                              kFi @ lift (If (e, s1, Skip)) |
                              subIf @ fun (s2) {If (e, s1, s2)}
                            })
                          })),
      st = memo $ eta (kRead |> lift (primary @ fun (Var (x)) { Read (x) }) |
                       kWrite |> lift (exp @ fun (x) { Write (x) }) |
                       kSkip @ lift (Skip) |
                       lident |> fun (x) { s(":=") |> lift (exp @ fun (e) { Assn (x, e) })} |
                       kIf |> lift (exp |> fun (e) {
                         kThen |> lift (stmt |> fun (s1) {
                           kElse |> lift (stmt |> fun (s2) {
                             kFi @ lift (If (e, s1, s2))
                           }) |
                           kFi @ lift (If (e, s1, Skip)) |
                           subIf @ fun (s2) { If (e, s1, s2) }
                         })
                       }) |
                       kWhile |> lift (exp |> fun (e) {
                         kDo |> lift (stmt |> fun (s) {
                           kOd @ lift (While (e, s))
                         })
                       }) |
                       kFor |> lift (stmt |> fun (s1) {
                         s(",") |> lift ( exp |> fun (e) {
                           s(",") |> lift (stmt |> fun (s2) {
                             kDo |> lift (stmt |> fun (s3) {
                               kOd @ lift (Seq (s1, While (e, Seq (s3, s2))))
                             })
                           })
                         })
                       }) |
                       kRepeat |> lift (stmt |> fun (s) {
                         kUntil |> lift (exp @ fun (e) { Repeat (s, e) })
                       }));

      
local stmt = memo $ eta (st | st |> fun (s1) { s(";") |> lift (stmt @ fun (s2) {Seq (s1, s2)})});

-- Public top-level parser
public parse = stmt;
