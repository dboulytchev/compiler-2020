-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

fun opPair(op) {
  [s(op), fun(l, r) {Binop(op, l, r)}]
}

local operations = {
  [
    Left,
    singleton( opPair("!!") )
  ],
  [
    Left,
    singleton( opPair("&&") )
  ],
  [
    Left,
    {
      opPair("<"),
      opPair("<="),
      opPair(">"),
      opPair(">="),
      opPair("=="),
      opPair("!=")
    }
  ],
  [
    Left,
    {
      opPair("+"),
      opPair("-")
    }
  ],
  [
    Left,
    {
      opPair("*"),
      opPair("/"),
      opPair("%")
    }
  ]
};

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun sInbr (l, p, r) {
  inbr (s (l), p, s (r))
}


-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident @ fun(x) {Var (x)} |
                            sInbr ("(", exp, ")"));


local exp = memo $ eta ( expr(operations, primary)(id) );

local stmt = memo $ eta ( 
    (s("read")  |> lift(sInbr("(", lident, ")"))) @ fun(z) {Read(z)}
  | (s("write") |> lift(primary)) @ fun(x) {Write(x)}
  | (lident  |> fun(var) {(s(":=") |> lift(exp)) @ fun(val) {Assn(var, val)}})
  | (s("while") |> lift(exp |> bypass( s ("do")))) |> fun(e) {
      (parse |> bypass (s ("od"))) @ fun(body) { While(e, body) } 
    }
);

local inParse = memo $ eta (
    empty @ lift(None)
  | ( s(";") |> lift(stmt) ) |> fun(z) { inParse @ fun(rest) {
     case rest of 
       None -> Some(z)
     | Some(v) -> Some(Seq(z, v))
     esac
  }}
);

-- Public top-level parser
public parse = memo $ eta (
  stmt |> fun(first) { inParse @ fun(rest) {case rest of 
      None -> first
    | Some(v) -> Seq(first, v)
    esac
  }}
);
