-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;


-- A parser of "something" in brackets; l, r are left and right
-- brackets as strings, p --- a parser of "something"
fun inbr (l, p, r) {
  l |> lift (p |> bypass (r))
}

fun binOp (op){
  [s(op), fun(left, right) { Binop (op, left, right) }]
}

local ops = { [Left, singleton (binOp ("!!"))],
              [Left, singleton (binOp ("&&"))],
              [Nona, { binOp ("<"), binOp ("<="), binOp (">="), binOp (">"),
                       binOp ("=="), binOp ("!=") }],
              [Left, { binOp ("+"), binOp ("-")}],
              [Left, { binOp ("*"), binOp ("/"), binOp ("%") }] };



-- Primary expression
local primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                            lident  @ fun (x) {Var (x)} |
                            inbr (s("("), exp, s(")")));

local exp = memo $ eta (expr (ops, primary)(id));

local stElif = memo $ eta ( kElif |> lift (exp |> fun (expr) {
                              kThen |> lift (stmt |> fun (stmt1) {
                                kElse |> lift (stmt |> fun (stmt2) {
                                  kFi @ lift (If (expr, stmt1, stmt2))
                                })
                                | kFi @ lift (If (expr, stmt1, Skip))
                                | stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                              })
                            })
                          );


local substmt = memo $ eta (kSkip @ lift (Skip)
                         | kRead |> lift (primary @ fun (Var (x)) { Read (x) })
                         | kWrite |> lift (exp @ fun (x) { Write (x) })
                         | lident |> fun (x) { s(":=") |> lift (exp @ fun (expr) {Assn (x, expr) }) }
                         | kIf |> lift (exp |> fun(expr) {
                             kThen |> lift (stmt |> fun (stmt1) {
                               kElse |> lift ( stmt |> fun (stmt2) {
                                 kFi @ lift (If (expr, stmt1, stmt2))
                               })
                               | kFi @ lift (If (expr, stmt1, Skip))
                               | stElif @ fun (stmt2) {If (expr, stmt1, stmt2)}
                             })
                           })
                         | kWhile |> lift (exp |> fun (expr) {
                             kDo |> lift (stmt |> fun (state) {
                               kOd @ lift (While (expr, state))
                             })
                           })
                         | kRepeat |> lift (stmt |> fun (state) {
                             kUntil |> lift (exp @ fun (expr) {Repeat (state, expr)})
                           })
                         | kFor |> lift (stmt |> fun (stmt1) {
                             s(",") |> lift (exp |> fun (expr) {
                               s(",") |> lift (stmt |> fun (stmt2) {
                                 kDo |> lift (stmt |> fun (stmt3) {
                                   kOd @ lift (Seq (stmt1, While (expr, Seq (stmt3, stmt2))))
                                 })
                               })
                             })
                           })
                         ); 



local stmt = memo $ eta (substmt 
                         | substmt |> fun (stmt1) { 
                             s(";") |> lift (stmt @ fun (stmt2) { Seq (stmt1, stmt2) })
                           }
                        );
   

-- Public top-level parser
public parse = stmt;
             
