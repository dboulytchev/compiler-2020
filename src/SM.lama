-- Stack machine.

import List;
import World;
import State;
import Expr;
import Util;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval ([stack, state, world], insns) {
  case insns of
        CONST(c):other            ->  eval([c:stack, state, world], other)
      | BINOP(operation):other    ->  case stack of
                                          right:left:rest -> eval([evalBinop(operation, left, right):rest, state, world], other)
                                      esac
      | LD(x):other               ->  eval([state(x):stack, state, world], other)
      | ST(x):other               ->  case stack of
                                          head:rest -> eval([rest, state <- [x, head], world], other)
                                      esac
      | READ:other                ->  case readWorld(world) of
                                          [value, newWorld] -> eval([value:stack, state, newWorld], other)
                                      esac
      | WRITE:other               ->  case stack of
                                          head:rest -> eval([rest, state, writeWorld(head, world)], other)
                                      esac
      | {}                        ->  c
    esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Const(x)    -> singleton(CONST(x))
    | Var(x)    -> singleton(LD(x))
    | Binop(operation, left, right) -> flatten({ compileExpr(left), compileExpr(right), singleton(BINOP(operation)) })
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  fun compile(stmt) {
    case stmt of
        Read(x)         ->  { READ, ST(x) }
    |   Write(value)    ->  { compileExpr(value), singleton(WRITE) }
    |   Assn(x, value)  ->  { compileExpr(value), singleton(ST(x)) }
    |   Seq(stmt1,stmt2)->  { compileSM(stmt1), compileSM(stmt2) }
  esac
  }
  deepFlatten (compile (stmt))
}
