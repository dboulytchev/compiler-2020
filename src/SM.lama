-- Stack machine.

import List;
import World;
import State;
import Expr;
import Util;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval (c@[stack, st, w], insns) {
  case insns of
      i : is ->
        local newc = 
          case i of 
              BINOP (op) ->
                case stack of 
                  r : l : tail -> [applyBinop (op, l, r) : tail, st, w]
                esac
            | CONST (a)  -> [a : stack, st, w]
            | READ       ->
                case readWorld (w) of
                  [v, neww] -> [v : stack, st, neww]
                esac  
            | WRITE      -> [tl (stack), st, writeWorld (hd (stack), w)]  
            | LD (x)     -> [st (x) : stack, st, w]
            | ST (x)     -> [tl (stack), st <- [x, hd (stack)], w]
          esac;
        eval (newc, is) 
      | {}   -> c  
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
  case expr of
      Const (a)        -> {CONST (a)}
    | Var   (x)        -> {LD (x)}
    | Binop (op, l, r) -> {compileExpr (l), compileExpr (r), BINOP (op)}
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {

  fun innerCompileSM (stmt) {
	  case stmt of
        Assn (x, e) -> {compileExpr (e), ST (x)}
      | Seq (l, r)  -> {innerCompileSM (l), innerCompileSM (r)}
      | Skip        -> {}
      | Read (x)    -> {READ, ST (x)}
      | Write (e)   -> {compileExpr (e), WRITE}
    esac
  }

  deepFlatten (innerCompileSM (stmt))
}
