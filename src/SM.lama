-- Stack machine.

import List;
import World;
import State;
import Expr;
import Util;

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval ([stack, state, world], command:insns, level) {
  case command of
    BINOP (op) -> case stack of
                      first:second:newStack ->
                        stack := evalExpr (state, Binop (op, Const (second), Const (first))) : newStack
                    | _ -> failure ("pop from empty stack\n")
                    esac
  | CONST (value) -> stack := value:stack
  | READ -> case readWorld(world) of
                [value, newWorld] -> stack := value:stack ;
                                     world := newWorld
              esac
  | WRITE -> case stack of
                 element:newStack -> stack := newStack ;
                                     world := writeWorld (element, world)
               | _ -> failure ("pop from empty stack\n")
               esac
  | LD (var) -> stack := state (var):stack
  | ST (var) -> case stack of
                    element:newStack -> stack := newStack ;
                                        state := state <- [var, element]
                  | _ -> failure ("pop from empty stack\n")
                  esac
  | _ -> failure ("invalid stack command: %s\n", command.string)
  esac ;

  case insns of
    {} -> [stack, state, world]
  | _:_ -> eval([stack, state, world], insns, level + 1)
  | _ -> failure ("bad stack\n")
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM (input, insns) {
  eval ([{}, emptyState, createWorld (input)], insns, 0)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list (of, possibly, lists)
-- of stack machine instructions
fun compileExpr (expr) {
  case expr of
    Var (var) -> LD (var):{}
  | Const (value) -> CONST (value):{}
  | Binop (op, lhs, rhs) -> {compileExpr(lhs), compileExpr(rhs), BINOP (op)}
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM (stmt) {
  case stmt of
    Skip -> {}
  | Assn (var, expr) -> {compileExpr(expr), ST(var)}
  | Read (var) -> {READ, ST (var)}
  | Write (expr) -> {compileExpr(expr), WRITE}
  | Seq (lhs, rhs) -> {compileSM(lhs), compileSM(rhs)}
  | _ -> failure ("invalid statement: %s\n", stmt.string)
  esac.deepFlatten
}
