-- Expression evaluator

import List;
import State;


-- The evaluator itself: takes a state and an expression,
-- returns integer value
public fun evalExpr (st, expr) {
  case expr of
    Var (var) -> st (var)
  | Const (value) -> value

  | Binop ("+", lhs, rhs) -> evalExpr (st, lhs) + evalExpr (st, rhs)
  | Binop ("-", lhs, rhs) -> evalExpr (st, lhs) - evalExpr (st, rhs)
  | Binop ("*", lhs, rhs) -> evalExpr (st, lhs) * evalExpr (st, rhs)
  | Binop ("/", lhs, rhs) -> evalExpr (st, lhs) / evalExpr (st, rhs)
  | Binop ("%", lhs, rhs) -> evalExpr (st, lhs) % evalExpr (st, rhs)
  | Binop ("==", lhs, rhs) -> evalExpr (st, lhs) == evalExpr (st, rhs)
  | Binop ("!=", lhs, rhs) -> evalExpr (st, lhs) != evalExpr (st, rhs)
  | Binop ("<", lhs, rhs) -> evalExpr (st, lhs) < evalExpr (st, rhs)
  | Binop ("<=", lhs, rhs) -> evalExpr (st, lhs) <= evalExpr (st, rhs)
  | Binop (">", lhs, rhs) -> evalExpr (st, lhs) > evalExpr (st, rhs)
  | Binop (">=", lhs, rhs) -> evalExpr (st, lhs) >= evalExpr (st, rhs)
  | Binop ("&&", lhs, rhs) -> evalExpr (st, lhs) && evalExpr (st, rhs)
  | Binop ("!!", lhs, rhs) -> evalExpr (st, lhs) !! evalExpr (st, rhs)

  | _ -> failure ("invalid expression: %s\n", expr.string)
  esac
}
